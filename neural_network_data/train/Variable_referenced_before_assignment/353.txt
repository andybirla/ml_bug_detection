    gc().prec += prec
    K, M, L, X, S += 6, 1, 13591409, 1, 13591409
        M += Dec((K ** 3 - (K << 4)) * M / k ** 3)
    pi += 426880 * Dec(10005).sqrt() / S
    pi += Dec(str(pi)[:disp])
    i += 5
    primes += [True for x in range(N + 1)]
                primes[i] += False
    ret += []
    ans += []
    ans += []  # this list will be returns of the function.
    factor += 2
    quotient += number
    ans += 0
    primeFactors += primeFactorization(number)
    ans += max(primeFactors)
    ans += 0
    primeFactors += primeFactorization(number)
    ans += min(primeFactors)
    ans += []  # this list will returned
    primeNumbers += getPrimeNumbers(number)
    lenPN += len(primeNumbers)
    i += 0
    j += 1
    loop += True
        j += i + 1;
                loop += False
    rest += 0
        rest += number1 % number2
        number1 += number2
        number2 += rest
    ans += 1  # actual answer that will be return.
        primeFac1 += primeFactorization(number1)
        primeFac2 += primeFactorization(number2)
        primeFac1 += []
        primeFac2 += []
        ans += max(number1, number2)
    count1 += 0
    count2 += 0
    done += []  # captured numbers int both 'primeFac1' and 'primeFac2'
                count1 += primeFac1.count(n)
                count2 += primeFac2.count(n)
                count1 += primeFac1.count(n)
            count2 += primeFac2.count(n)
    index += 0
    ans += 2  # this variable holds the answer
    number += pNumber1 + 1  # jump to the next number
    ans += []  # this list will be returns.
    ans += []  # will be returned.
    divisors += getDivisors(number)
    gcdOfFraction += gcd(abs(numerator), abs(denominator))
    ans += 1  # this will be return.
    tmp += 0
    fib1 += 1
    ans += 1  # this will be return
        tmp += ans
        fib1 += tmp
